# TZX Format Specification

* Format revision: v1.20
* 19 Dec 2006


**Table of Contents**

1. Introduction
2. Rules and definitions
3. TZX file format
4. Hardware information reference
5. Machine specific information
6. Deprecated blocks
7. Revision history



## Introduction

TZX is a file format designed to preserve all (hopefully) of the tapes with
turbo or custom loading routines. Even though some of the newer and 'smarter'
emulators can find most of the info about the loader from the code itself,
this isn't possible if you want to save the file to tape, or to a real
Spectrum. And with all this information in the file, the emulators don't have
to bother with finding out the timings and other things.

This file format is explicitly targeted to the ZX Spectrum compatible
computers only. Specialized versions of the TZX format have been defined for
other machines too, e.g. the Amstrad CPC and C64, but they are now available
as distinct file formats with other filename extensions.

At the end of this document you can find a description of encoding differences
between these machines and a table which displays timings used by their
respective ROM loading routines (some of them are not official). If you know
of any other machines that have similar encoding that could be represented
with this file format then let us know.

If you're looking for TZX files, you can find an extensive collection at
Martijn van der Heide's 'World of Spectrum'.

The format was first started off by Tomaz Kac who was maintainer until
revision 1.13, and then passed to Martijn v.d. Heide. After that, Ramsoft were
the maintainers for a brief period during which the v1.20 revision was put
together. If you have any questions about the format, visit the forums at
World of Spectrum and ask.

The default format file extension is `TZX` and hopefully this won't have to
change in the future; for RISC OS, the current `TAP` file type will be used.
Amstrad CPC files should use the extension `CDT` to distinguish them from the
ZX Spectrum files, otherwise the inner structure is totally the same.



## Rules and definitions

* Any value requiring more than one byte is stored in little endian format (i.e. LSB first).
* All unused bits should be set to zero.
* The timings are given in Z80 clock ticks (T states) unless otherwise stated.
  `1 T state = (1/3500000)s`
* The block IDs are given in hex.
* All ASCII texts use the ISO 8859-1 (Latin 1) encoding; some of themcan have
  several lines, which should be separated by ASCII code `13` decimal (`0D` hex).
* You might interpret 'full-period' as `----____` or `____----`, and
  'half-period' as `----` or `____`. One 'half-period' will also be referred to
  as a 'pulse'.
* The values in curly brackets `{}` are the default values that are used in the
  Spectrum ROM saving routines.These values are in decimal.
* If there is no pause between two data blocks then the second one should
  follow immediately; not even so much as one T state between them.
* This document refers to 'high' and 'low' pulse levels. Whether this is
  implemented as ear=1 and ear=0 respectively or the other way around is not
  important, as long as it is done consistently.
* Zeros and ones in 'Direct recording' blocks mean low and high pulse levels
  respectively. The 'current pulse level' after playing a Direct Recording
  block of CSW recording block is the last level played.
* The 'current pulse level' after playing the blocks ID `10`,`11`,`12`,`13`,`14`
  or `19` is the opposite of the last pulse level played, so that a subsequent
  pulse will produce an edge.
* A 'Pause' block consists of a 'low' pulse level of some duration. To ensure
  that the last edge produced is properly finished there should be at least
  1 ms. pause of the opposite level and only after that the pulse should go to
  'low'. At the end of a 'Pause' block the 'current pulse level' is low (note
  that the first pulse will therefore not immediately produce an edge). A
  'Pause' block of zero duration is completely ignored, so the 'current pulse
  level' will NOT change in this case. This also applies to 'Data' blocks that
  have some pause duration included in them.
* An emulator should put the 'current pulse level' to 'low' when starting to
  play a TZX file, either from the start or from a certain position. The
  writer of a TZX file should ensure that the 'current pulse level' is
  well-defined in every sequence of blocks where this isimportant, i.e. in any
  sequence that includes a 'Direct recording' block, or that depends on edges
  generated by 'Pause' blocks. The commended way of doing this is to include a
  Pause after each sequence of blocks.
* When creating a 'Direct recording' block please stick to the standard sampling
  frequencies of 22050 or 44100 Hz. This will ensure correct playback when using
  PC's soundcards.
* The length of a block is given in the following format: numbers in square
  brackets `[]` mean that the value must be read from the offset in the brackets.
  Other values are normal numbers. Example: `[02,03]+0A` means: get number (a word)
  from offset `02` and add `0A`. All numbers are in hex.
* General Extension Rule: ALL custom blocks that will be added after version 1.10
  will have the length of the block in first 4 bytes (long word) after the ID
  (this length does not include these 4 length bytes). This should enable
  programs that can only handle older versions to skip that block.
* Just in case:
    - MSB = most significant byte
    - LSB = least significant byte
    - MSb = most significant bit
    - LSb = least significant bit



## TZX file format



### TZX Header (length: `10 bytes`)

| Offset | Value     | Type     | Description               |
|  0x00  | `ZXTape!` | ASCII[7] | TZX signature             |
|  0x07  | 0x1A      | BYTE     | End of text file marker   |
|  0x08  | 1         | BYTE     | TZX major revision number |
|  0x09  | 20        | BYTE     | TZX minor revision number |

The file is identified with the first 8 bytes being `ZXTape!` plus the 'end of
file' byte `26` (`1A` hex). This is followed by two bytes containing the major and
minor version numbers.

To be able to use a TZX file, your program (emulator, utility, or whatever)
must be able to handle files of at least its major version number. If your
program can handle (say) version 1.05 and you encounter a file with version
number 1.06, your program must be able to handle it, even if it cannot handle
all the data in the file.

Then the main body of the file follows. It consists of a mixture of blocks,
each identified by an ID byte.

**TZX block ID list:**

* ID `10` - Standard speed data block
* ID `11` - Turbo speed data block
* ID `12` - Pure tone
* ID `13` - Sequence of pulses of various lengths
* ID `14` - Pure data block
* ID `15` - Direct recording block
* ID `18` - CSW recording block
* ID `19` - Generalized data block
* ID `20` - Pause (silence) or 'Stop the tape' command
* ID `21` - Group start
* ID `22` - Group end
* ID `23` - Jump to block
* ID `24` - Loop start
* ID `25` - Loop end
* ID `26` - Call sequence
* ID `27` - Return from sequence
* ID `28` - Select block
* ID `2A` - Stop the tape if in 48K mode
* ID `2B` - Set signal level
* ID `30` - Text description
* ID `31` - Message block
* ID `32` - Archive info
* ID `33` - Hardware type
* ID `35` - Custom info block
* ID `5A` - "Glue" block (90 dec, ASCII Letter 'Z')



### ID `10` - Standard Speed Data Block (length: `[02,03]+04`)

| Offset | Value | Type    | Description                           |
|  0x00  |   -   | WORD    | Pause after this block (ms.) `{1000}` |
|  0x02  |   N   | WORD    | Length of data that follow            |
|  0x04  |   -   | BYTE[N] | Data as in .TAP files                 |

This block must be replayed with the standard Spectrum ROM timing values - see
the values in curly brackets in block `ID 11`. The pilot tone consists in 8063
pulses if the first data byte (flag byte) is < 128, 3223 otherwise. This block
can be used for the ROM loading routines AND for custom loading routines that
use the same timings as ROM ones do.



### ID `11` - Turbo Speed Data Block (length: `[0F,10,11]+12`)

| Offset | Value | Type    | Description                                     |
|  0x00  |   -   | WORD    | Length of PILOT pulse `{2168}`                  |
|  0x02  |   -   | WORD    | Length of SYNC first pulse `{667}`              |
|  0x04  |   -   | WORD    | Length of SYNC second pulse `{735}`             |
|  0x06  |   -   | WORD    | Length of ZERO bit pulse `{855}`                |
|  0x08  |   -   | WORD    | Length of ONE bit pulse `{1710}`                |
|  0x0A  |   -   | WORD    | Length of PILOT tone (number of pulses)         | {8063 header (flag<128), 3223 data (flag>=128)}
|  0x0C  |   -   | BYTE    | Used bits in the last byte (other bits should   |
                             be 0) `{8}` (e.g. if this is 6, then the bits
                             used (x) in the last byte are: xxxxxx00, where
                             MSb is the leftmost bit,
                             LSb is the rightmost bit)
|  0x0D  |   -   | WORD    | Pause after this block (ms.) `{1000}`           |
|  0x0F  |   N   | BYTE[3] | Length of data that follow                      |
|  0x12  |   -   | BYTE[N] | Data as in .TAP files                           |

This block is very similar to the normal TAP block but with some additional
info on the timings and other important differences. The same tape encoding is
used as for the standard speed data block. If a block should use some
non-standard sync or pilot tones (i.e. all sorts of protection schemes) then
use the next three blocks to describe it.



### ID `12` - Pure Tone (length: `04`)

| Offset | Value | Type | Description                     |
|  0x02  |   -   | WORD | Number of pulses                |
|  0x00  |   -   | WORD | Length of one pulse in T-states |

This will produce a tone which is basically the same as the pilot tone in the
`ID 10`, `ID 11` blocks. You can define how long the pulse is and how many pulses
are in the tone.



### ID `13` - Pulse sequence (length: `[00]x02+01`)

| Offset | Value | Type    | Description      |
|  0x00  |   N   | BYTE    | Number of pulses |
|  0x01  |   -   | WORD[N] | Pulses' lengths  |

This will produce N pulses, each having its own timing. Up to 255 pulses can
be stored in this block; this is useful for non-standard sync tones used by
some protection schemes.



### ID `14` - Pure Data Block (length: `[07,08,09]+0A`)

| Offset | Value | Type    | Description                                     |
|  0x00  |   -   | WORD    | Length of ZERO bit pulse                        |
|  0x02  |   -   | WORD    | Length of ONE bit pulse                         |
|  0x04  |   -   | BYTE    | Used bits in last byte (other bits should be 0) |
                             (e.g. if this is 6, then the bits used (x) in
                             the last byte are: `xxxxxx00`, where
                             MSb is the leftmost bit,
                             LSb is the rightmost bit)
|  0x05  |   -   | WORD    | Pause after this block (ms.)                    |
|  0x07  |   N   | BYTE[3] | Length of data that follow                      |
|  0x0A  |   -   | BYTE[N] | Data as in .TAP files                           |

This is the same as in the turbo loading data block, except that it has no
pilot or sync pulses.



### ID `15` - Direct Recording (length: `[05,06,07]+08`)

| Offset | Value | Type    | Description                                    |
|  0x00  |   -   | WORD    | Number of T-states per sample (bit of data)    |
|  0x02  |   -   | WORD    | Pause after this block in milliseconds (ms.)   |
|  0x04  |   -   | BYTE    | Used bits (samples) in last byte of data (1-8) |
                             (e.g. if this is 2, only first two samples of
                             the last byte will be played)
|  0x05  |   N   | BYTE[3] | Length of samples' data                        |
|  0x08  |   -   | BYTE[N] | Samples data. Each bit represents a state on   |
                             the EAR port (i.e. one sample). MSb is played
                             first.

This block is used for tapes which have some parts in a format such that the
turbo loader block cannot be used. This is not like a VOC file, since the
information is much more compact. Each sample value is represented by one bit
only (0 for low, 1 for high) which means that the block will be at most 1/8
the size of the equivalent VOC. The preferred sampling frequencies are 22050
or 44100 Hz (158 or 79 T-states/sample). Please, if you can, don't use other
sampling frequencies.

Please use this block only if you cannot use any other block.



### ID `18` - CSW Recording (length: `[00,01,02,03]+04`)

| Offset | Value | Type    | Description                             |
|  0x00  | 10+N  | DWORD   | Block length (without these four bytes) |
|  0x04  |   -   | WORD    | Pause after this block (in ms).         |
|  0x06  |   -   | BYTE[3] | Sampling rate                           |
|  0x09  |   -   | BYTE    | Compression type                        |
|  0x0A  |   -   | DWORD   | Number of stored pulses (after          |
                             decompression, for validation purposes)
|  0x0E  |   -   | BYTE[N] | CSW data, encoded according to the CSW  |
                             file format specification.

This block contains a sequence of raw pulses encoded in CSW format v2
(Compressed Square Wave).



### ID `19` - Generalized Data Block (length: `[00,01,02,03]+04`)

| Offset            | Value | Type        | Description                                                |
|  0x00             |   -   | DWORD       | Block length (without these four bytes)                    |
|  0x04             |   -   | WORD        | Pause after this block (ms)                                |
|  0x06             | TOTP  | DWORD       | Total number of symbols in pilot/sync block (can be 0)     |
|  0x0A             | NPP   | BYTE        | Maximum number of pulses per pilot/sync symbol             |
|  0x0B             | ASP   | BYTE        | Number of pilot/sync symbols in the alphabet table (0=256) |
|  0x0C             | TOTD  | DWORD       | Total number of symbols in data stream (can be 0)          |
|  0x10             | NPD   | BYTE        | Maximum number of pulses per data symbol                   |
|  0x11             | ASD   | BYTE        | Number of data symbols in the alphabet table (0=256)       |
|  0x12             |   -   | SYMDEF[ASP] | Pilot and sync symbols definition table                    |
|  0x12+
   (2*NPP+1)*ASP    |   -   | PRLE[TOTP]  | Pilot and sync data stream                                 |
|  0x12+
   (TOTP>0)*
   ((2*NPP+1)*ASP)+
   TOTP*3           |   -   | SYMDEF[ASD] | Data symbols definition table                              |
|  0x12+
   (TOTP>0)*
   ((2*NPP+1)*ASP)+
   TOTP*3+
   (2*NPD+1)*ASD    |   -   | BYTE[DS]    | Data stream                                                |

This block has been specifically developed to represent an extremely wide
range of data encoding techniques. The basic idea is that each loading
component (pilot tone, sync pulses, data) is associated to a specific sequence
of pulses, where each sequence (wave) can contain a different number of pulses
from the others. In this way we can have a situation where bit 0 is
represented with 4 pulses and bit 1 with 8 pulses.

| SYMDEF structure forma |
| Offset | Value | Type       | Description             |
|  0x00  |   -   | BYTE       | Symbol flags            |
|  0x01  |   -   | WORD[MAXP] | Array of pulse lengths. |

The alphabet is stored using a table where each symbol is a row of pulses. The
number of columns (i.e. pulses) of the table is the length of the longest
sequence amongst all (`MAXP` = `NPP` or `NPD`, for pilot/sync or data blocks
respectively); shorter waves are terminated by a zero-length pulse in the
sequence.

Any number of data symbols is allowed, so we can have more than two distinct
waves; for example, imagine a loader which writes two bits at a time by
encoding them with four distinct pulse lengths: this loader would have an
alphabet of four symbols, each associated to a specific sequence of pulses
(wave).

| PRLE structure format |
| Offset | Value | Type | Description              |
|  0x00  |   -   | BYTE | Symbol to be represented |
|  0x01  |   -   | WORD | Number of repetitions    |

Most commonly, pilot and sync are repetitions of the same pulse, thus they are
represented using a very simple RLE encoding structure which stores the symbol
and the number of times it must be repeated.

Each symbol in the data stream is represented by a string of `NB` bits of the
block data, where `NB = ceiling(Log2(ASD))`. Thus the length of the whole data
stream in bits is `NB*TOTD`, or in bytes `DS=ceil(NB*TOTD/8)`.

**Example**

A typical Spectrum's standard loading header can be represented like this:

| Offset | Value             | Description                                                 |
|  0x00  |  59 (0x3B)        | Total block length                                          |
|  0x04  |  1000 (0x03E8)    | Pause after this block (ms.)                                |
|  0x06  |  2                | Total number of symbols in pilot/sync block                 |
|  0x0A  |  2                | Max pulses per symbol                                       |
|  0x0B  |  2                | Number of symbols in pilot/sync alphabet                    |
|  0x0C  |  152 (0x98)       | Total number of symbols (bits, in this case) in data stream |
|  0x10  |  2                | Max pulses per data symbol                                  |
|  0x11  |  2                | Number of symbols in data alphabet                          |
|  0x12  | SYMDEF[0]:        | Pilot/sync symbol definitions                               |
            ( 0, 2168, 0 )
           SYMDEF[1]:
            ( 0, 667, 735)
|  0x1C  | PRLE[0]:          | Pilot/sync data block                                       |
            ( 0, 8063 )
           PRLE[1]:
            ( 1, 1)
|  0x22  | SYMDEF[0]:        | Data symbol definitions                                     |
            ( 0, 855, 855 )
           SYMDEF[1]:
            ( 0, 1710, 1710)
|  0x2C  | 00000000 - 0x00   | Data stream:                                                |
           00000011 - 0x03       00: loading flag (0x00 = header)
           01001010 - 0x4A       03: data type (0x03 = "Bytes:")
           01010000 - 0x50       4A,50,53,50,20,20,20,20,20,20: file name ("JPSP")
           01010011 - 0x53       1B00: data length
           01010000 - 0x50       4000: start address
           00100000 - 0x20       8000: autostart (no meaning here)
           00100000 - 0x20       C1: checksum
           00100000 - 0x20
           00100000 - 0x20
           00100000 - 0x20
           00100000 - 0x20
           00000000 - 0x00
           00011011 - 0x1B
           00000000 - 0x00
           01000000 - 0x40
           00000000 - 0x00
           10000000 - 0x80
           11000001 - 0xC1


The very same data information encoded to work with the ZX81 would look like this:

| Offset | Value                          | Description                                 |
|  0x00  | 107 (0x6B)                     | Total block length                          |
|  0x04  | 1000 (0x03E8)                  | Pause after this block (ms.)                |
|  0x06  | 0                              | Total number of records in pilot/sync block |
|  0x0A  | 0                              | Max pulses per symbol                       |
|  0x0B  | 0                              | Number of symbols in pilot/sync alphabet    |
|  0x0C  | 152 (0x98)                     | Total number of records in data stream      |
|  0x10  | 18 (0x12)                      | Max pulses per data symbol                  |
|  0x11  | 2                              | Number of symbols in data alphabet          |
|  0x12  | SYMDEF[0]:                     | Data symbol definitions                     |
           ( 3, 530, 520, 530, 520, 530,
            520, 530, 4689, 0, 0, 0, 0,
            0, 0, 0, 0, 0, 0 )
           SYMDEF[1]:
           ( 3, 530, 520, 530, 520, 530,
            520, 530, 520, 530, 520, 530,
            520, 530, 520, 530, 520, 530,
            4689 )
|  0x5C  | 00000000 - 0x00                | Data stream                                 |
           00000011 - 0x03
           01001010 - 0x4A
           01010000 - 0x50
           01010011 - 0x53
           01010000 - 0x50
           00100000 - 0x20
           00100000 - 0x20
           00100000 - 0x20
           00100000 - 0x20
           00100000 - 0x20
           00100000 - 0x20
           00000000 - 0x00
           00011011 - 0x1B
           00000000 - 0x00
           01000000 - 0x40
           00000000 - 0x00
           10000000 - 0x80
           11000001 - 0xC1



### ID `20` - Pause (silence) or 'Stop the Tape' command (length: `02`)

| Offset | Value | Type | Description          |
|  0x00  |   -   | WORD | Pause duration (ms.) |

This will make a silence (low amplitude level (0)) for a given time in
milliseconds. If the value is 0 then the emulator or utility should (in
effect) `STOP THE TAPE`, i.e. should not continue loading until the user or
emulator requests it.



### ID `21` - Group start (length: `[00]+01`)

| Offset | Value | Type    | Description                                                          |
|  0x00  |   L   | BYTE    | Length of the group name string                                      |
|  0x01  |   -   | CHAR[L] | Group name in ASCII format (please keep it under 30 characters long) |

This block marks the start of a group of blocks which are to be treated as one
single (composite) block. This is very handy for tapes that use lots of
subblocks like Bleepload (which may well have over 160 custom loading blocks).
You can also give the group a name (example 'Bleepload Block 1').

For each group start block, there must be a group end block. Nesting of groups
is not allowed.



### ID `22` - Group end (length: `00`)

This indicates the end of a group. This block has no body.



### ID `23` - Jump to block (length: `02`)

| Offset | Value | Type | Description         |
|  0x00  |   -   | WORD | Relative jump value |

This block will enable you to jump from one block to another within the file.
The value is a signed short word (usually 'signed short' in C); Some examples:

* Jump  0 = 'Loop Forever' - this should never happen
* Jump  1 = 'Go to the next block' - it is like `NOP` in assembler ;)
* Jump  2 = 'Skip one block'
* Jump -1 = 'Go to the previous block'

All blocks are included in the block count!



### ID `24` - Loop start (length: `02`)

| Offset | Value | Type | Description                            |
|  0x00  |   -   | WORD | Number of repetitions (greater than 1) |

If you have a sequence of identical blocks, or of identical groups of blocks,
you can use this block to tell how many times they should be repeated. This
block is the same as the `FOR` statement in BASIC.

For simplicity reasons don't nest loop blocks!



### ID `25` - Loop end (length: `00`)

This is the same as BASIC's `NEXT` statement. It means that the utility should
jump back to the start of the loop if it hasn't been run for the specified
number of times.

This block has no body.



### ID `26` - Call sequence (length: `[00,01]x02+02`)

| Offset | Value | Type    | Description                                           |
|  0x00  |   N   | WORD    | Number of calls to be made                            |
|  0x02  |   -   | WORD[N] | Array of call block numbers (relative-signed offsets) |

This block is an analogue of the `CALL` Subroutine statement. It basically
executes a sequence of blocks that are somewhere else and then goes back to
the next block. Because more than one call can be normally used you can
include a list of sequences to be called. The 'nesting' of call blocks is also
not allowed for the simplicity reasons. You can, of course, use the `CALL`
blocks in the `LOOP` sequences and vice versa. The value is relative for the
obvious reasons - so that you can add some blocks in the beginning of the file
without disturbing the call values. Please take a look at 'Jump To Block' for
reference on the values.



### ID `27` - Return from sequence (length: `00`)

This block indicates the end of the Called Sequence. The next block played
will be the block after the last `CALL` block (or the next Call, if the Call
block had multiple calls).

Again, this block has no body.



### ID `28` - Select block (length: `[00,01]+02`)

| Offset | Value | Type      | Description                                         |
|  0x00  |   -   | WORD      | Length of the whole block (without these two bytes) |
|  0x02  |   N   | BYTE      | Number of selections                                |
|  0x03  |   -   | SELECT[N] | List of selections                                  |


| SELECT structure format |
| Offset | Value | Type    | Description                                                 |
|  0x00  |   -   | WORD    | Relative Offset                                             |
|  0x02  |   L   | BYTE    | Length of description text                                  |
|  0x03  |   -   | CHAR[L] | Description text (please use single line and max. 30 chars) |

This block is useful when the tape consists of two or more separately-loadable
parts. With this block, you are able to select one of the parts and the
utility/emulator will start loading from that block. For example you can use
it when the game has a separate Trainer or when it is a multiload. Of course,
to make some use of it the emulator/utility has to show a menu with the
selections when it encounters such a block. All offsets are relative signed
hwords.



### ID `2A` - Stop the tape if in 48K mode (length: `04`)

| Offset | Value | Type  | Description                                      |
|  0x00  |   0   | DWORD | Length of the block without these four bytes (0) |

When this block is encountered, the tape will stop ONLY if the machine is an
48K Spectrum. This block is to be used for multiloading games that load one
level at a time in 48K mode, but load the entire tape at once if in 128K mode.

This block has no body of its own, but follows the extension rule.



### ID `2B` - Set signal level (length: `05`)

| Offset | Value | Type  | Description                             |
|  0x00  |   1   | DWORD | Block length (without these four bytes) |
|  0x04  |   -   | BYTE  | Signal level (`0`=low, `1`=high)        |

This block sets the current signal level to the specified value (high or low).
It should be used whenever it is necessary to avoid any ambiguities, e.g. with
custom loaders which are level-sensitive.



### ID `30` - Text description (length: `[00]+01`)

| Offset | Value | Type    | Description                      |
|  0x00  |   N   | BYTE    | Length of the text description   |
|  0x01  |   -   | CHAR[N] | Text description in ASCII format |

This is meant to identify parts of the tape, so you know where level 1 starts,
where to rewind to when the game ends, etc. This description is not guaranteed
to be shown while the tape is playing, but can be read while browsing the tape
or changing the tape pointer.

The description can be up to 255 characters long but please keep it down to
about 30 so the programs can show it in one line (where this is appropriate).

Please use 'Archive Info' block for title, authors, publisher, etc.



### ID `31` - Message block (length: `[01]+02`)

| Offset | Value | Type    | Description                                                 |
|  0x00  |   -   | BYTE    | Time (in seconds) for which the message should be displayed |
|  0x01  |   N   | BYTE    | Length of the text message                                  |
|  0x02  |   -   | CHAR[N] | Message that should be displayed in ASCII format            |

This will enable the emulators to display a message for a given time. This
should not stop the tape and it should not make silence. If the time is 0 then
the emulator should wait for the user to press a key.

The text message should:

* stick to a maximum of 30 chars per line;
* use single `0x0D` (13 decimal) to separate lines;
* stick to a maximum of 8 lines.

If you do not obey these rules, emulators may display your message in any way
they like.



### ID `32` - Archive info (length: `[00,01]+02`)

| Offset | Value | Type    | Description                                         |
|  0x00  |   -   | WORD    | Length of the whole block (without these two bytes) |
|  0x02  |   N   | BYTE    | Number of text strings                              |
|  0x03  |   -   | TEXT[N] | List of text strings                                |


| TEXT structure format |
| Offset | Value | Type    | Description                      |
|  0x00  |   -   | BYTE    | Text identification byte:        |
                              `00` - Full title
                              `01` - Software house/publisher
                              `02` - Author(s)
                              `03` - Year of publication
                              `04` - Language
                              `05` - Game/utility type
                              `06` - Price
                              `07` - Protection scheme/loader
                              `08` - Origin FF - Comment(s)
|  0x01  |   L   | BYTE    | Length of text string            |
|  0x02  |   -   | CHAR[L] | Text string in ASCII format      |

Use this block at the beginning of the tape to identify the title of the game,
author, publisher, year of publication, price (including the currency), type
of software (arcade adventure, puzzle, word processor, ...), protection scheme
it uses (Speedlock 1, Alkatraz, ...) and its origin (Original, Budget
re-release, ...), etc. This block is built in a way that allows easy future
expansion. The block consists of a series of text strings. Each text has its
identification number (which tells us what the text means) and then the ASCII
text. To make it possible to skip this block, if needed, the length of the
whole block is at the beginning of it.

If all texts on the tape are in English language then you don't have to supply
the 'Language' field.

The information about what hardware the tape uses is in the 'Hardware Type'
block, so no need for it here.



### ID `33` - Hardware type (length: `[00]x03+01`)

| Offset | Value | Type      | Description                                                      |
|  0x00  |   N   | BYTE      | Number of machines and hardware types for which info is supplied |
|  0x01  |   -   | HWINFO[N] | List of machines and hardware                                    |

|                 HWINFO structure format                 |
| Offset | Value | Type | Description                     |
|  0x00  |   -   | BYTE | Hardware type                   |
|  0x01  |   -   | BYTE | Hardware ID                     |
|  0x02  |   -   | BYTE | Hardware information: see below |

**Hardware information**

* `00` - The tape RUNS on this machine or with this hardware, but may or may not use the hardware or special features of the machine.
* `01` - The tape USES the hardware or special features of the machine, such as extra memory or a sound chip.
* `02` - The tape RUNS but it DOESN'T use the hardware or special features of the machine.
* `03` - The tape DOESN'T RUN on this machine or with this hardware.

This blocks contains information about the hardware that the programs on this
tape use. Please include only machines and hardware for which you are 100%
sure that it either runs (or doesn't run) on or with, or you know it uses (or
doesn't use) the hardware or special features of that machine.

If the tape runs only on the ZX81 (and TS1000, etc.) then it clearly won't
work on any Spectrum or Spectrum variant, so there's no need to list this
information.

If you are not sure or you haven't tested a tape on some particular
machine/hardware combination then do not include it in the list.

The list of hardware types and IDs is somewhat large, and may be found at the
end of the format description.



### ID `35` - Custom info block (length: `[10,11,12,13]+14`)

| Offset | Value | Type     | Description                      |
|  0x00  |   -   | CHAR[10] | Identification string (in ASCII) |
|  0x10  |   L   | DWORD    | Length of the custom info        |
|  0x14  |   -   | BYTE[L]  | Custom info                      |

This block can be used to save any information you want. For example, it might
contain some information written by a utility, extra settings required by a
particular emulator, or even poke data.



### ID `5A` - "Glue" block (length: `09`)

| Offset | Value | Type    | Description                     |
|  0x00  |   -   | BYTE[9] | Value:                          | { "ZXTape!",0x1A,MajR,MinR }
                             Just skip these 9 bytes and you
                             will end up on the next ID.

This block is generated when you merge two ZX Tape files together. It is here
so that you can easily copy the files together and use them. Of course, this
means that resulting file would be 10 bytes longer than if this block was not
used. All you have to do if you encounter this block ID is to skip next 9
bytes. If you can avoid using this block for this purpose, then do so; it is
preferable to use a utility to join the two files and ensure that they are
both of the higher version number.



## Hardware information reference

This is the list of all hardware types and hardware identification ID's that
are used in the 'Hardware info' block. Please send any additions you might
have to the TZX maintainers so that they can be included.

By default you don't have to write any of the information if the game is made
for the ZX Spectrum and complies with the following:

* runs on ZX Spectrum 48K
* runs on, but doesn't use any of the special hardware of ZX Spectrum 128K
* doesn't run on ZX Spectrum 16K

If, for example, game works on BOTH ZX 48K and 128K, and uses the hardware of
the 128K Spectrum, then you would just include the 128K Spectrum in the list
(because by default it has to work on 48K too).

If the game is 128K ONLY then you would include two entries: The game works on
AND uses the hardware of a 128K Spectrum AND the game DOESN'T work on a 48K
Spectrum.

If the game works on both 48K and 128K Spectrum, but it only uses the sound
chip (AY) of the 128K Spectrum and none of its extra memory then you would
only include the entry that says that the game uses the 'Classic AY hardware
(Spectrum 128 sompatible sound device)'.

These were only some examples of the usage of this block.



### Hardware types

* `00` - Computers
* `01` - External storage
* `02` - ROM/RAM type add-ons
* `03` - Sound devices
* `04` - Joysticks
* `05` - Mice
* `06` - Other controllers
* `07` - Serial ports
* `08` - Parallel ports
* `09` - Printers
* `0A` - Modems
* `0B` - Digitizers
* `0C` - Network adapters
* `0D` - Keyboards & keypads
* `0E` - AD/DA converters
* `0F` - EPROM programmers
* `10` - Graphics



## Hardware IDs

**`00` - Computers**

00 - ZX Spectrum 16k
01 - ZX Spectrum 48k, Plus
02 - ZX Spectrum 48k ISSUE 1
03 - ZX Spectrum 128k +(Sinclair)
04 - ZX Spectrum 128k +2 (grey case)
05 - ZX Spectrum 128k +2A, +3
06 - Timex Sinclair TC-2048
07 - Timex Sinclair TS-2068
08 - Pentagon 128
09 - Sam Coupe
0A - Didaktik M
0B - Didaktik Gama
0C - ZX-80
0D - ZX-81
0E - ZX Spectrum 128k, Spanish version
0F - ZX Spectrum, Arabic version
10 - Microdigital TK 90-X
11 - Microdigital TK 95
12 - Byte
13 - Elwro 800-3
14 - ZS Scorpion 256
15 - Amstrad CPC 464
16 - Amstrad CPC 664
17 - Amstrad CPC 6128
18 - Amstrad CPC 464+
19 - Amstrad CPC 6128+
1A - Jupiter ACE
1B - Enterprise
1C - Commodore 64
1D - Commodore 128
1E - Inves Spectrum+
1F - Profi
20 - GrandRomMax
21 - Kay 1024
22 - Ice Felix HC 91
23 - Ice Felix HC 2000
24 - Amaterske RADIO Mistrum
25 - Quorum 128
26 - MicroART ATM
27 - MicroART ATM Turbo 2
28 - Chrome
29 - ZX Badaloc
2A - TS-1500
2B - Lambda
2C - TK-65
2D - ZX-97


**`01` - External storage**

* `00` - ZX Microdrive
* `01` - Opus Discovery
* `02` - MGT Disciple
* `03` - MGT Plus-D
* `04` - Rotronics Wafadrive
* `05` - TR-DOS (BetaDisk)
* `06` - Byte Drive
* `07` - Watsford
* `08` - FIZ
* `09` - Radofin
* `0A` - Didaktik disk drives
* `0B` - BS-DOS (MB-02)
* `0C` - ZX Spectrum +3 disk drive
* `0D` - JLO (Oliger) disk interface
* `0E` - Timex FDD3000
* `0F` - Zebra disk drive
* `10` - Ramex Millenia
* `11` - Larken
* `12` - Kempston disk interface
* `13` - Sandy
* `14` - ZX Spectrum +3e hard disk
* `15` - ZXATASP
* `16` - DivIDE
* `17` - ZXCF


**`02` - ROM/RAM type add-ons**

* `00` - Sam Ram
* `01` - Multiface ONE
* `02` - Multiface 128k
* `03` - Multiface +3
* `04` - MultiPrint
* `05` - MB-02 ROM/RAM expansion
* `06` - SoftROM
* `07` - 1k
* `08` - 16k
* `09` - 48k
* `0A` - Memory in 8-16k used


**`03` - Sound devices**

classic AY hardware (compatible with 128k ZXs)
* `01` - Fuller Box AY sound hardware
* `02` - Currah microSpeech
* `03` - SpecDrum
* `04` - AY ACB stereo (A+C=left, B+C=right); Melodik
* `05` - AY ABC stereo (A+B=left, B+C=right)
* `06` - RAM Music Machine
* `07` - Covox
* `08` - General Sound
* `09` - Intec Electronics Digital Interface B8001
* `0A` - Zon-X AY
* `0B` - QuickSilva AY
* `0C` - Jupiter ACE


**`04` - Joysticks**

* `00` - Kempston
* `01` - Cursor, Protek, AGF
* `02` - Sinclair 2 Left (12345)
* `03` - Sinclair 1 Right (67890)
* `04` - Fuller


**`05` - Mice**

* `00` - AMX mouse
* `01` - Kempston mouse


**`06` - Other controllers**

* `00` - Trickstick
* `01` - ZX Light Gun
* `02` - Zebra Graphics Tablet
* `03` - Defender Light Gun


**`07` - Serial ports**

* `00` - ZX Interface 1
* `01` - ZX Spectrum 128k


**`08` - Parallel ports**

* `00` - Kempston S
* `01` - Kempston E
* `02` - ZX Spectrum +3
* `03` - Tasman
* `04` - DK'Tronics
* `05` - Hilderbay
* `06` - INES Printerface
* `07` - ZX LPrint Interface 3
* `08` - MultiPrint
* `09` - Opus Discovery
* `0A` - Standard 8255 chip with ports 31,63,95


**`09` - Printers**

* `00` - ZX Printer, Alphacom 32 & compatibles
* `01` - Generic printer
* `02` - EPSON compatible


**`0A` - Modems**

* `00` - Prism VTX 5000
* `01` - T/S 2050 or Westridge 2050


**`0B` - Digitizers**

* `00` - RD Digital Tracer
* `01` - DK'Tronics Light Pen
* `02` - British MicroGraph Pad
* `03` - Romantic Robot Videoface


**`0C` - Network adapters**

* `00` - ZX Interface 1


**`0D` - Keyboards & keypads**

* `00` - Keypad for ZX Spectrum 128k


**`0E` - AD/DA converters**

* `00` - Harley Systems ADC 8.2
* `01` - Blackboard Electronics


**`0F` - EPROM programmers**

* `00` - Orme Electronics


**`10` - Graphics**

* `00` - WRX Hi-Res
* `01` - G007
* `02` - Memotech
* `03` - Lambda Colour



## Machine specific information

Currently supported machines are: ZX Spectrum, Amstrad CPC, SAM Coupe, ZX-81
Jupiter ACE and Enterprise. Only ZX-81 (or the old Timex 1000) and Jupiter ACE
use different tape encoding than the others.

* **Jupiter ACE encoding** - see [a dedicated site](http://www.jupiter-ace.co.uk/doc_AceTapeFormat.html).
* **ZX Spectrum, Amstrad CPC, SAM Coupe & Enterprise tape encoding**

These computers share the same tape encoding, which is normal frequency type
encoding. Each bit is represented by one 'wave' ofdifferent duration for bit 0
and bit 1. Normally bit 1 is twice as bigas bit 0. In the blocks, the timings
are presented with Z80 T-states(cycles) per pulse. One wave is made from two
pulses.

The standard data blocks have always the same structure: first there is the
PILOT tone, then the two SYNC pulses (one wave) and after that the actual DATA
(which can include a FLAG byte at the beginning and a CHECKSUM byte at the
end).

Here is a table showing the pulse timings for each part of the standard ROM
load/save routine for each of these machines. If you have more accurate
information then we would be glad to include it here. Enterprise has two
loading speeds so timings for both are included.

| Machine           | Pilot pulse | Length | Sync1  | Sync2   | Bit 0  | Bit 1       |
| ZX Spectrum       |   2168      |   (1)  | 667    | 735     | 855    | 1710        |
| SAM Coupe'        |   58+19*W   |  6000  | 58+9*W | 113+9*W | 10+8*W | 42+15*W (i) |
| Amstrad CPC       |   Bit 1     |  4096  | Bit 0  | Bit 0   |  (2)   |  (2)        |
| Enterprise (fast) |   742       |    ?   | 1280   | 1280    | 882    | 602 (ii)    |
| Enterprise (slow) |   1750      |    ?   | 2800   | 2800    | 1982   | 1400 (ii)   |

**Notes:**

(1) The Spectrum uses different pilot lengths for header and data blocks.
    Header blocks have 8063 and data blocks have 3223 pilot pulses.

(2) Amstrad CPC ROM load/save routine can use variable speed for loading, so the
    bit 1 pulse must be read from the pilot tone and bit 0 can be read from the
    sync pulses, and is always half the size of bit 1. The checksum is also
    different than the other two machines. The speed can vary from 1000 to 2000 baud.

(i) The SAM Coupe' timings can be user selected by a system variable.
    The standard value is 112, which is VERY close to ZX Spectrum loading speed,
    and therefore the 'Standard Speed Data' block can be used for those blocks.
    However if this system variable is changed then the timings will change
    accordingly. In the above table the value of this variable is given as 'W',
    the 'H' value is 'W/2'. Of course the best way to determine it is to
    calculate it from the timings you get when sampling the Pilot tone. The
    values in the table could be by a fraction of the real ones, but it should
    not matter. Note: All timings are written in 3.5MHz clock. Also, there might
    be some junk bits (usually 7or 8) AFTER the checksum (XOR) byte at the end
    of the block, but they can just be ignored.

(ii) The Enterprise stores data in a different way than all other computers do.
     It stores the LSb first, but the data blocks require the data to be MSb
     first. This might lead to some confusion, but if the same mechanism is used
     to replay data for all machines then there will be no problem. Just store
     the data as MSb first, but if you want to view the raw data in the TZX file
     then you will have to mirror each byte to get the correct values.

**IMPORTANT:** The ZXTape format has ALL timings written according to a 3.5MHz
clock (the standard Spectrum 16/48K clock), so if the tape should be used on an
Amstrad CPC with 4MHz clock then you should multiply ALL timings with 4/3.5 when
you use that tape (this should be trivial). Similarly goes for SAM Coupe, that
uses a 6MHz clock and Jupiter ACE that uses 3.2448 MHz and Enterprise that uses
4MHz!



## Deprecated blocks

The following blocks, which were in the format until revision 1.13 (inclusive),
have now been deprecated and they should not appear in TZX files v1.20 and
above. Their structure is documented here for completeness, to allow general
tools and emulators to maintain full backward compatibility with old TZX files.
However note that these blocks have not proven to be useful and, as a
consequence, it appears that almost no existing TZX files contain them.

* ID `16` - C64 ROM type data block
* ID `17` - C64 turbo tape data block
* ID `34` - Emulation info
* ID `35` - Custom info deprecated types
* ID `40` - Snapshot block



### ID `16` - C64 ROM Type Data Block (length: `[00,01,02,03]`)

| Offset | Value | Type    | Description                                  |
|  0x00  |   -   | DWORD   | Length of the WHOLE block including the      |
                             data (extension rule)
|  0x04  |   -   | WORD    | PILOT TONE pulse length [616]                |
|  0x06  |   -   | WORD    | Number of waves in PILOT TONE                |
|  0x08  |   -   | WORD    | SYNC first wave pulse length [1176]          |
|  0x0A  |   -   | WORD    | SYNC 2nd wave pulse length [896]             |
|  0x0C  |   -   | WORD    | ZERO bit 1st wave pulse length [616]         |
|  0x0E  |   -   | WORD    | ZERO bit 2nd wave pulse length [896]         |
|  0x10  |   -   | WORD    | ONE bit 1st wave pulse length [896]          |
|  0x12  |   -   | WORD    | ONE bit 2nd wave pulse length [616]          |
|  0x14  |   -   | BYTE    | XOR Checksum bit for each Data byte: [1]     |
                              00 - Start XOR checksum with value 0
                              01 - Start XOR checksum with value 1
                              FF - No checksum bit
|  0x15  |   -   | WORD    | FINISH BYTE 1st wave pulse length [1176]     |
|  0x17  |   -   | WORD    | FINISH BYTE 2nd wave pulse length [896]      |
|  0x19  |   -   | WORD    | FINISH DATA 1st wave pulse length [1176]     |
|  0x1B  |   -   | WORD    | FINISH DATA 2nd wave pulse length [616]      |
|  0x1D  |   -   | WORD    | TRAILING TONE pulse length [616]             |
|  0x1F  |   -   | WORD    | Number of waves in TRAILING TONE             |
|  0x21  |   -   | BYTE    | Used bits in last byte (other bits           |
                             should be 0) (e.g. if this is 6, then
                             the bits used (x) in last byte are:
                             xxxxxx00)
|  0x22  |   -   | BYTE    | General Purpose, bit-mapped: [1]             |
                               bit 0 - Data Endianess:
                                 0 = LSb first,
                                 1 = MSb first
|  0x23  |   -   | WORD    | Pause after this block in milliseconds (ms.) |
|  0x25  |   N   | BYTE[3] | Length of following data                     |
|  0x28  |   -   | BYTE[N] | Data as in .TAP files                        |

Well, this block was created to support the Commodore 64 standard ROM and
similar tape blocks. It is made so basically anything that uses two or four
pulses (which are the same in pairs) per bit can be written with it. Some
explanation:

* A wave consists of TWO pulses. The structure contains the length of ONE pulse.
* The wave MUST always start with the LOW amplitude, since the C64 can only
  detect the transition HIGH -> LOW.
* If some pulse length is 0 then the whole wave must not be present.
  This applies to DATA too.
* The XOR checksum (if it is set to 0 or 1) is a XOR of all bits inthe byte
  XOR-ed with the value in this field as the start value.
* Finish Byte waves should be played after each byte EXCEPT last one.
* Finish Data waves should be ONLY played after last byte of data.
* When all the Data has finished there is an optional Trailer Tone, which is
  standard for the Repeated Blocks in C64 ROM Loader.

The replay procedure looks like this:

1. Pilot Tone
2. Sync waves
3. Data Bytes (with XOR and/or Finish Byte waves)
4. Finish Data pulses
5. Trailing Tone

NOTE: the numbers in brackets `[]` represent the values for C64 ROM loader.



### ID `17` - C64 Turbo Tape Data Block (length: `[00,01,02,03]`)

| Offset | Value | Type    | Description                                         |
|  0x00  |   -   | DWORD   | Length of the WHOLE block including the data        |
                             (extension rule)
|  0x04  |   -   | WORD    | ZERO bit pulse                                      |
|  0x06  |   -   | WORD    | ONE bit pulse                                       |
|  0x08  |   -   | BYTE    | Additional bits in bytes (bit-mapped)               |
                            bits 0-1: number of bits (0-3)
                            bit    2: play additional bit(s)
                                      BEFORE (0) or AFTER (1) the byte
                            bit    3: value of additional bit(s)
|  0x09  |   -   | WORD    | Number of lead-in bytes                             |
|  0x0B  |   -   | BYTE    | Lead-in byte                                        |
|  0x0C  |   -   | BYTE    | Used bits in last byte (other bits should be 0) [8] |
                              (e.g. if this is 6, then the bits used (x) in last
                              byte are: xxxxxx00)
|  0x0D  |   -   | BYTE    | General purpose (bit-mapped) [0]                    |
                               bit 0: little (0) or big (1) endian format
|  0x0E  |   -   | WORD    | Number of trailing bytes                            |
|  0x10  |   -   | BYTE    | Trailing byte                                       |
|  0x11  |   -   | WORD    | Pause after this block in milliseconds (ms.)        |
|  0x13  |   N   | BYTE[3] | Length of following data                            |
|  0x16  |   -   | BYTE[N] | Data as in .TAP files                               |

This block is made to support another type of encoding that is commonly
used by the C64. Most of the commercial software uses this type of
encoding, i.e. the Pilot tone is not made from one type of Wave only,
but it is made from actual Data byte which is repeated many times. As
the Sync value another, different, Data byte is sent to signal the
start of the data. The Data Bits are made from ONE wave only and there
is NO XOR checksum either! Trailing byte is played AFTER the DATA has
ended.



### ID `34` - Emulation info (length: `08`)

| Offset | Value | Type    | Description                                                            |
|  0x00  |   -   | WORD    | General emulation flags:                                               |
                             bit 0 : R-register emulation [1] bit 1 : LDIR emulation [1]
                             bit 2 : high resolution colour emulation with true interrupt freq. [1]
                             bit 3,4 : video synchronisation :
                                         1=high, 3=low, 0,2=normal [0]
                             bit 5 : fast loading when ROM load routine is used [1]
                             bit 6 : border emulation [1]
                             bit 7 : screen refresh mode (1: ON, 0: OFF) [1]
                             bit 8 : start playing the tape immediately [0]
                                     If this is 0 then the emulator should only load the info
                                     blocks and WAIT when it encounters first DATA block
                             bit 9 : auto type LOAD"" or press ENTER when in 128k mode [0]
|  0x02  |   -   | BYTE    | Screen refresh delay :1 - 255 (interrupts between refreshes) [1]       |
                             (used when screen refresh mode is ON)                                  |
|  0x03  |   -   | WORD    | Interrupt Frequency : 0 - 999 Hz                                       |
|  0x05  |   -   | BYTE[3] | Reserved for future expansion                                          |

This is a special block that would normally be generated only by emulators.
For now it contains info on everything I could find that other formats
support. Please inform me of any additions/corrections since this is a very
// important part for emulators.

Those bits that are not used by the emulator that stored the info, should be
left at their DEFAULT values.


### ID `35` - Custom Info: deprecated sub-blocks

Some of the most common uses of the Custom Info block (`ID 35`) have become
standardized in the past revisions, although now they are deprecated:

#### POKEs block

The purpose of this custom block is to hold any amount of different trainers
for the game.

| Offset    | Value | Type       | Description                           |
|  0x00     |   -   | CHAR[10]   | "POKEs" + 11 spaces (custom block ID) |
|  0x10     |   -   | DWORD      | Length of data that follow            |
|  0x14     |   L   | BYTE       | General description length            |
|  0x15     |   -   | CHAR[L]    | General description in ASCII format   |
|  0x15+L   |   N   | BYTE       | Number of trainers                    |
|  0x15+L+1 |   -   | TRAINER[N] | Trainer definitions                   |

Each trainer can have its own description and any number of POKEs.

|                  TRAINER structure format                         |
| Offset    | Value | Type    | Description                         |
|  0x00     |   L   | BYTE    | Trainer description length          |
|  0x01     |   -   | CHAR[L] | Trainer description in ASCII format |
|  0x01+L   |   N   | BYTE    | Number of pokes in this trainer     |
|  0x01+L+1 |   -   | POKE[N] | POKEs definitions                   |

For each POKE entry you can supply the memory page number and/or the original
value of the address (if you want to restore it some way through the game).
Normally you would enter these pokes with the help of some freezer-type tool
like Multiface, but hopefully in the future the emulators will support this
block directly, in which case you could use the 'User inserts the POKE value'
feature. You can specify the point at which to insert the POKEs in the 'General
description' field.

NOTE: All ASCII Descriptions can use more than one line. Please use only up to
30 characters per line and separate the lines by one CR (13dec).

|                        POKE structure format                               |
| Offset | Value | Type | Description                                        |
|  0x00  |   -   | BYTE | POKE type:                                         |
                          bit 0-2 : memory page number
                          bit 3 : ignore memory page number
                          bit 4 : user inserts the POKE value
                          bit 5 : unknown original value
|  0x01  |   -   | WORD | POKE address |
|  0x03  |   -   | BYTE | POKE value (leave 0 if 'user inserts' bit set)     |
|  0x04  |   -   | BYTE | POKE original value (leave 0 if 'unknown' bit set) |



#### Instructions block

This block can hold any general .TXT file, with the main purpose of storing the
instructions to the program or game that is in the tape. To ensure consistency
with all other ASCII texts in this format please use a single `CR` character
(`13` dec, `0D` hex) to separate lines; also please use only up to 80
characters per line.

| Offset | Value | Type     | Description                                 |
|  0x00  |   -   | CHAR[10] | "Instructions" + 4 spaces (custom block ID) |
|  0x10  |   L   | DWORD    | Length of the following data                |
|  0x14  |   -   | BYTE[L]  | Instructions text in ASCII format           |



#### Spectrum screen block

If the game on the tape is not an original and lacks the original loading
screen then you can supply it separately within this block. This is also very
handy when you want the loading screen stored separately because the original
is either encrypted (like with the 'Speedlock' or 'Alkatraz' loaders) or it is
corrupted by some on-screen info (like the 'Bleepload' loader). Of course not
only loading screens can be stored here... you can use it to store maps or any
other picture that is in Spectrum Video format (that's why the Description is
there for), but because the Loading Screen will be the most common you can
just set the description length field to 0 when you use it for that. Also the
border colour can be specified.

| Offset    | Value | Type       | Description                                       |
|  0x00     |   -   | CHAR[10]   | "Spectrum Screen" + 1 spaces (custom block ID)    |
|  0x10     |   -   | DWORD      | Length of data that follow                        |
|  0x14     |   L   | BYTE       | Description length                                |
                                   (if this is 0 then handle it as 'Loading Screen')
|  0x15     |   -   | CHAR[L]    | Description of the picture in ASCII format        |
|  0x15+L   |   -   | BYTE       | BORDER Colour in Spectrum colour format           |
                                   (0=black, 1=blue, ...)
|  0x15+L+1 |   -   | BYTE[6912] | Screen in standard Spectrum video format          |



#### ZX-Edit document block

This block can hold files created with the new utility called ZX-Editor. This
utility gives documents the look and feel of ZX-Spectrum and its documents can
contain text, graphics (with Spectrum attributes), different type faces,
colours, etc. Normally these files use extension `.ZED`. Also the description is
added, in case you want to use it for something else than 'Instructions' - you
can use it for MAPs, etc.

| Offset  | Value | Type     | Description                                     |
|  0x00   |   -   | CHAR[10] | "ZX-Edit document" (custom block ID)            |
|  0x10   |   -   | DWORD    | Length of data that follow                      |
|  0x14   |   L   | BYTE     | Description length                              |
                               (if this is 0 then handle it as 'Instructions')
|  0x15   |   -   | CHAR[L]  | Description of the document in ASCII format     |
|  0x15+L |   -   | BYTE[]   | The ZX-Editor document (.ZED file)              |



#### Picture block

Finally you can include any picture (in supported formats) in the TZX file too.
So cover pictures, maps, etc. can now be included in full colour (or whatever
the formats supports). The best way for utilities to use this block is to spawn
an external viewer, or the authors can write their own viewers (yeah, right ;).
For inlay cards and other pictures that have zillions of colours use the
JPEG format, for more simple pictures (drawing, maps, etc.) use the GIF format.

| Offset  | Value | Type     | Description                                                      |
|  0x00   |   -   | CHAR[10] | "Picture" + 9 spaces (custom block ID)                           |
|  0x10   |   -   | DWORD    | Length of data that follow                                       |
|  0x14   |   -   | BYTE     | Picture format: 00 - GIF 01 - JPEG                               |
|  0x15   |   L   | BYTE     | Description length (if this is 0 then handle it as 'Inlay Card') |
|  0x16   |   -   | CHAR[L]  | Description of the document in ASCII format                      |
|  0x16+L |   -   | BYTE[]   | The picture itself                                               |



### ID `40` - Snapshot block (length: `[01,02,03]+04`)

| Offset | Value | Type    | Description                                    |
|  0x00  |   -   | BYTE    | Snapshot type: 00: .Z80 format 01: .SNA format |
|  0x01  |   L   | BYTE[3] | Snapshot length                                |
|  0x04  |   -   | BYTE[L] | Snapshot itself                                |

This would enable one to snapshot the game at the start and still have all the
tape blocks (level data, etc.) in the same file. Only `.Z80` and `.SNA`
snapshots are supported for compatibility reasons! The emulator should take
care of that the snapshot is not taken while the actual Tape loading is taking
place (which doesn't do much sense). And when an emulator encounters the
snapshot block it should load it and then continue with the next block.



## Revision history

**Revision 1.20**

* The following blocks have been deprecated and should not appear in TZX files
  v1.20 and above: C64 blocks (`ID 16` and `ID 17`), Emulation Info (`ID 34`),
  Snapshot block (`ID 40`).
  These block IDs are now reserved.
* All Custom Info (`ID 35`) types standardized up to Revision 1.13 are now deprecated.
* The following new blocks have been introduced: `ID 18`, `ID 19`, `ID 2B`.
  Newly added blocks follow the general extension rule.
* Added new entries to the hardware ID list:
  `00/1E-2D`, `01/12-17`, `02/06-0A`, `03/06-0C`, `06/03`, `0B/03`, `10/00-03`

**Revision 1.13**

* The following new blocks have been introduced: `ID 16`, `ID 17`
* Added new entries to the hardware ID list: `00/1C,1D`

**Revision 1.12**

* Added the following fields to the 'Archive info' (`ID 32`) block:
  - 05 - Game/Utility Type
  - 06 - Price
  - 07 - Protection Scheme / Loader
  - 08 - Origin
* Added two new types of 'Custom info' (`ID 35`) block:
  - 'ZX-Edit document' - for .ZED files generated by the great ZX-Editor!
  - 'Picture ' - for .GIF and .JPEG (.JPG) pictures
* Added new entries to the hardware ID list: `00/1A,1B`

**Revision 1.10**

* The following new blocks have been introduced: `ID 24`, `ID 25`, `ID 26`, `ID 27`, `ID 28`, `ID 40`
* Allowed multiple lines in the 'Archive info' (`ID 32`) block.
  Also added the following field:
  - 04 - Language
* First three types of 'Custom info' (`ID 35`) block standardized:
  - 'POKEs'
  - 'Instructions'
  - 'Screen'

**Revision 1.02**

* Added new entries to the hardware ID list: `00/15-19`

**Revision 1.01**

* The Length of ASCII ID in 'Custom Info' block (`ID 35`) should be 16 and not
  15 bytes - even Tomaz Kac doesn't remember if it concerns only documentation
  or also the implementation; to be sure consider the block `ID 35` as newly
  added in revision 1.01
